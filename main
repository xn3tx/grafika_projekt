import pygame
from pygame.locals import *
from OpenGL.GL import *
from OpenGL.GLU import *
import math
import time
import sys
import tkinter as tk
from tkinter import ttk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import threading

WIDTH, HEIGHT = 800, 600
FPS = 60

class ParameterControl:
    def open_control_window(system):
        def update_parameters():
            try:
                system.spring.k = float(k_entry.get())
                system.attenuator.b = float(b_entry.get())
                system.platform_amp = float(a_entry.get())
                system.platform_freq = float(f_entry.get())
            except ValueError:
                pass

        def plot_response():
            t_vals = []
            x_vals = []

            temp_t = 0
            x = 0
            v = 0
            for _ in range(1000):
                y_wheel = system.platform_amp * math.sin(2 * math.pi * system.platform_freq * temp_t)
                y_rel = x - y_wheel
                a = (-system.spring.k * y_rel - system.attenuator.b * v) / system.mass
                v += a * 0.01
                x += v * 0.01
                temp_t += 0.01
                t_vals.append(temp_t)
                x_vals.append(x)

            fig.clear()
            ax = fig.add_subplot(111)
            ax.plot(t_vals, x_vals, label='Wy')
            ax.set_xlabel('Czas [s]')
            ax.set_ylabel('Przemieszczenie [px]')
            ax.legend()
            canvas.draw()

        window = tk.Tk()
        window.title("Zmiana parametrów zawieszenia")

        ttk.Label(window, text="Współczynnik sprężystości (k):").pack()
        k_entry = ttk.Entry(window)
        k_entry.insert(0, str(system.spring.k))
        k_entry.pack()

        ttk.Label(window, text="Współczynnik tłumienia (b):").pack()
        b_entry = ttk.Entry(window)
        b_entry.insert(0, str(system.attenuator.b))
        b_entry.pack()

        ttk.Label(window, text="Amplituda drgań platformy (A):").pack()
        a_entry = ttk.Entry(window)
        a_entry.insert(0, str(system.platform_amp))
        a_entry.pack()

        ttk.Label(window, text="Częstotliwość drgań platformy (f):").pack()
        f_entry = ttk.Entry(window)
        f_entry.insert(0, str(system.platform_freq))
        f_entry.pack()

        ttk.Button(window, text="Zastosuj", command=update_parameters).pack(pady=5)
        ttk.Button(window, text="Wykres stabilności", command=plot_response).pack()

        fig = plt.Figure(figsize=(5, 3), dpi=100)
        canvas = FigureCanvasTkAgg(fig, master=window)
        canvas.get_tk_widget().pack()

        window.mainloop()

class Drawing:
    @staticmethod   #umożliwia wywołanie bez tworzenia obiektu
    def set_2d_projection():
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        gluOrtho2D(0, WIDTH, HEIGHT, 0)  # układ współrzędnych zgodny z Pygame
        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()

    @staticmethod
    def draw_rect(x, y, w, h, color):
        glColor3f(*[c / 255.0 for c in color])
        glBegin(GL_QUADS)
        glVertex2f(x, y)
        glVertex2f(x + w, y)
        glVertex2f(x + w, y + h)
        glVertex2f(x, y + h)
        glEnd()

    @staticmethod
    def draw_line(x1, y1, x2, y2, color, width=1):
        glLineWidth(width)
        glColor3f(*[c / 255.0 for c in color])
        glBegin(GL_LINES)
        glVertex2f(x1, y1)
        glVertex2f(x2, y2)
        glEnd()

    def draw_scene(y_wheel, y_desk, system):
        glClear(GL_COLOR_BUFFER_BIT)
        center_x = WIDTH // 2
        platform_y = HEIGHT // 2 + int(y_wheel)
        desk_y = int(y_desk)
        ground_y = HEIGHT - 40

        # Podłoże
        Drawing.draw_line(0, ground_y, WIDTH, ground_y, (80, 80, 80), 6)

        # Platforma
        system.draw_platform(center_x, platform_y, ground_y)

        # Koło
        wheel_bottom_y = platform_y
        system.wheel.draw_wheel(center_x, wheel_bottom_y)
        wheel_axis_y = wheel_bottom_y - system.wheel.height // 2

        # Podwozie
        beam_start_x = center_x + system.wheel.width // 2
        beam_end_x = beam_start_x + 100
        Drawing.draw_line(beam_start_x, wheel_axis_y, beam_end_x, wheel_axis_y, (150, 150, 150), 8)
        Drawing.draw_rect(center_x + 50, desk_y, 200, 20, (180, 180, 180))

        # Sprężyna i tłumik
        spring_x = beam_end_x - 60
        attenuator_x = beam_end_x + 10
        system.spring.draw_spring(spring_x, wheel_axis_y, desk_y)
        system.attenuator.draw_attenuator(attenuator_x, wheel_axis_y, desk_y)

class Wheel:
    def __init__(self, width=60, height=100):
        self.width = width
        self.height = height

    def draw_wheel(self, center_x, bottom_y):
        Drawing.draw_rect(center_x - self.width // 2, bottom_y - self.height, self.width, self.height, (40, 40, 40))
        # Bieżnik opony - poziome linie
        for y in range(bottom_y - self.height + 5, bottom_y, 10):
            Drawing.draw_line(center_x - self.width // 2, y, center_x + self.width // 2, y, (100, 100, 100), 2)

class Spring:
    def __init__(self):
        self.k = 200.0

    def draw_spring(self, attach_x, wheel_y, desk_y):
        spring_top = desk_y + 20
        Drawing.draw_line(attach_x, spring_top, attach_x, wheel_y, (0, 255, 0), 4)

class Attenuator:
    def __init__(self):
        self.b = 20.0

    def draw_attenuator(self, attach_x, wheel_y, desk_y):
        spring_top = desk_y + 20
        attenuator_y = (spring_top + wheel_y) // 2
        Drawing.draw_rect(attach_x - 10, attenuator_y - 20, 20, 40, (255, 165, 0))

class InputPlatform:
    def __init__(self):
        self.wheel = Wheel()
        self.spring = Spring()
        self.attenuator = Attenuator()

        self.platform_freq = 1.0
        self.platform_amp = 50.0
        self.mass = 1.0

        self.t = 0.0
        self.x = 0.0
        self.v = 0.0

    def platform_motion(self, time):
        return self.platform_amp * math.sin(2 * math.pi * self.platform_freq * time)

    def update_motion(self, dt):
        self.t += dt
        y_wheel = self.platform_motion(self.t)
        y_rel = self.x - y_wheel
        a = (-self.spring.k * y_rel - self.attenuator.b * self.v) / self.mass
        self.v += a * dt
        self.x += self.v * dt
        return y_wheel, self.x

    def draw_platform(self, center_x, platform_y, ground_y):
        Drawing.draw_line(center_x, platform_y + 20, center_x, ground_y, (180, 180, 180), 12)
        Drawing.draw_rect(center_x - 150, platform_y, 300, 20, (100, 100, 255))

def main():
    pygame.init()
    screen = pygame.display.set_mode((WIDTH, HEIGHT), DOUBLEBUF | OPENGL)
    pygame.display.set_caption("Symulacja zawieszenia samochodu")
    Drawing.set_2d_projection()
    clock = pygame.time.Clock()
    system = InputPlatform()
    threading.Thread(target=ParameterControl.open_control_window, args=(system,), daemon=True).start()

    while True:
        dt = clock.tick(FPS) / 1000.0

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

        y_wheel, y_desk = system.update_motion(dt)
        Drawing.draw_scene(y_wheel, y_desk, system)
        pygame.display.flip()

if __name__ == "__main__":
    main()


