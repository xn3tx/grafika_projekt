import pygame
from pygame.locals import *
from OpenGL.GL import *
from OpenGL.GLU import *
import math
import time
import sys
import tkinter as tk
from tkinter import ttk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import threading

WIDTH, HEIGHT = 800, 600
FPS = 60

class ParameterControl:
    def open_control_window(system):
        def update_parameters():
            try:
                new_k = float(k_entry.get())
                new_b = float(b_entry.get())
                new_a = float(a_entry.get())
                new_f = float(f_entry.get())

                if not (10 <= new_k <= 1000):
                    raise ValueError("Błąd - k musi być w zakresie 10–1000")
                if not (0 <= new_b <= 100):
                    raise ValueError("Błąd - b musi być w zakresie 0–100")
                if not (0 <= new_a <= 200):
                    raise ValueError("Błąd - A musi być w zakresie 0–200")
                if not (0.1 <= new_f <= 10):
                    raise ValueError("Błąd - f musi być w zakresie 0.1–10")

                # Zapisanie poprawnych wartości
                system.spring.k = new_k
                system.attenuator.b = new_b
                system.platform_amp = new_a
                system.platform_freq = new_f

                error_label.config(text="Zapisano parametry poprawnie", foreground="green")

            except ValueError as e:
                error_label.config(text=str(e), foreground="red")

        def output_plot():
            try:
                new_k = float(k_entry.get())
                new_b = float(b_entry.get())
                new_a = float(a_entry.get())
                new_f = float(f_entry.get())

                if not (10 <= new_k <= 1000):
                    raise ValueError("Błąd - k musi być w zakresie 10–1000")
                if not (0 <= new_b <= 100):
                    raise ValueError("Błąd - b musi być w zakresie 0–100")
                if not (0 <= new_a <= 200):
                    raise ValueError("Błąd - A musi być w zakresie 0–200")
                if not (0.1 <= new_f <= 10):
                    raise ValueError("Błąd - f musi być w zakresie 0.1–10")

                t_vals = []
                x_vals = []
                temp_t = 0
                x = 0
                v = 0

                for _ in range(1000):
                    y_wheel = new_a * math.sin(2 * math.pi * new_f * temp_t)
                    y_rel = x - y_wheel
                    a = (-new_k * y_rel - new_b * v) / system.mass
                    v += a * 0.01
                    x += v * 0.01
                    temp_t += 0.01
                    t_vals.append(temp_t)
                    x_vals.append(x)

                fig.clear()
                ax = fig.add_subplot(111)
                ax.plot(t_vals, x_vals, label='Wy')
                ax.set_xlabel('Czas [s]')
                ax.set_ylabel('Przemieszczenie [px]')
                ax.legend()
                canvas.draw()

                error_label.config(text="", foreground="green")

            except ValueError as e:
                error_label.config(text=f"Nie można wygenerować wykresu: {str(e)}", foreground="red")

        window = tk.Tk()
        window.title("Zmiana parametrów zawieszenia")

        ttk.Label(window, text="Współczynnik sprężystości (k):").pack()
        k_entry = ttk.Entry(window)
        k_entry.insert(0, str(system.spring.k))
        k_entry.pack()

        ttk.Label(window, text="Współczynnik tłumienia (b):").pack()
        b_entry = ttk.Entry(window)
        b_entry.insert(0, str(system.attenuator.b))
        b_entry.pack()

        ttk.Label(window, text="Amplituda drgań platformy (A):").pack()
        a_entry = ttk.Entry(window)
        a_entry.insert(0, str(system.platform_amp))
        a_entry.pack()

        ttk.Label(window, text="Częstotliwość drgań platformy (f):").pack()
        f_entry = ttk.Entry(window)
        f_entry.insert(0, str(system.platform_freq))
        f_entry.pack()

        ttk.Button(window, text="Zastosuj", command=update_parameters).pack(pady=5)
        ttk.Button(window, text="Wykres stabilności", command=output_plot).pack()

        # Miejsce na komunikat
        error_label = ttk.Label(window, text="", foreground="red")
        error_label.pack(pady=5)

        fig = plt.Figure(figsize=(5, 3), dpi=100)
        canvas = FigureCanvasTkAgg(fig, master=window)
        canvas.get_tk_widget().pack()

        window.mainloop()

class Drawing:
    @staticmethod   #umożliwia wywołanie bez tworzenia obiektu
    def set_2d_projection():
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        gluOrtho2D(0, WIDTH, HEIGHT, 0)  # układ współrzędnych zgodny z Pygame
        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()

    @staticmethod
    def draw_rect(x, y, w, h, color):
        glColor3f(*[c / 255.0 for c in color])
        glBegin(GL_QUADS)
        glVertex2f(x, y)
        glVertex2f(x + w, y)
        glVertex2f(x + w, y + h)
        glVertex2f(x, y + h)
        glEnd()

    @staticmethod
    def draw_line(x1, y1, x2, y2, color, width=1):
        glLineWidth(width)
        glColor3f(*[c / 255.0 for c in color])
        glBegin(GL_LINES)
        glVertex2f(x1, y1)
        glVertex2f(x2, y2)
        glEnd()

    def draw_scene(y_wheel, y_desk, system):
        glClear(GL_COLOR_BUFFER_BIT)
        center_x = WIDTH // 2
        platform_y = HEIGHT // 2 + int(y_wheel)
        desk_y = int(y_desk)
        ground_y = HEIGHT - 40

        # Podłoże
        Drawing.draw_line(0, ground_y, WIDTH, ground_y, (80, 80, 80), 6)

        # Platforma
        system.draw_platform(center_x, platform_y, ground_y)

        # Koło
        wheel_bottom_y = platform_y
        system.wheel.draw_wheel(center_x, wheel_bottom_y)
        wheel_axis_y = wheel_bottom_y - system.wheel.height // 2

        # Podwozie
        beam_start_x = center_x + system.wheel.width // 2
        beam_end_x = beam_start_x + 100
        Drawing.draw_line(beam_start_x, wheel_axis_y, beam_end_x, wheel_axis_y, (150, 150, 150), 8)
        Drawing.draw_rect(center_x + 50, desk_y, 200, 20, (180, 180, 180))

        # Sprężyna i tłumik
        spring_x = beam_end_x - 60
        attenuator_x = beam_end_x + 10
        system.spring.draw_spring(spring_x, wheel_axis_y, desk_y)
        system.attenuator.draw_attenuator(attenuator_x, wheel_axis_y, desk_y)

class Wheel:
    def __init__(self, width=60, height=100):
        self.width = width
        self.height = height

    def draw_wheel(self, center_x, bottom_y):
        Drawing.draw_rect(center_x - self.width // 2, bottom_y - self.height, self.width, self.height, (40, 40, 40))
        # Bieżnik opony - poziome linie
        for y in range(bottom_y - self.height + 5, bottom_y, 10):
            Drawing.draw_line(center_x - self.width // 2, y, center_x + self.width // 2, y, (100, 100, 100), 2)

class Spring:
    def __init__(self):
        self.k = 200.0

    def draw_spring(self, attach_x, wheel_y, desk_y):
        spring_top = desk_y + 20
        Drawing.draw_line(attach_x, spring_top, attach_x, wheel_y, (0, 255, 0), 4)

class Attenuator:
    def __init__(self):
        self.b = 20.0

    def draw_attenuator(self, attach_x, wheel_y, desk_y):
        spring_top = desk_y + 20
        attenuator_y = (spring_top + wheel_y) // 2
        Drawing.draw_rect(attach_x - 10, attenuator_y - 20, 20, 40, (255, 165, 0))

class InputPlatform:
    def __init__(self):
        self.wheel = Wheel()
        self.spring = Spring()
        self.attenuator = Attenuator()

        self.platform_freq = 1.0
        self.platform_amp = 50.0
        self.mass = 1.0

        self.t = 0.0
        self.x = 0.0
        self.v = 0.0

    def platform_motion(self, time):
        return self.platform_amp * math.sin(2 * math.pi * self.platform_freq * time)

    def update_motion(self, dt):
        self.t += dt
        y_wheel = self.platform_motion(self.t)
        y_rel = self.x - y_wheel
        a = (-self.spring.k * y_rel - self.attenuator.b * self.v) / self.mass
        self.v += a * dt
        self.x += self.v * dt
        return y_wheel, self.x

    def draw_platform(self, center_x, platform_y, ground_y):
        Drawing.draw_line(center_x, platform_y + 20, center_x, ground_y, (180, 180, 180), 12)
        Drawing.draw_rect(center_x - 150, platform_y, 300, 20, (100, 100, 255))

def main():
    pygame.init()
    screen = pygame.display.set_mode((WIDTH, HEIGHT), DOUBLEBUF | OPENGL)
    pygame.display.set_caption("Symulacja zawieszenia samochodu")
    Drawing.set_2d_projection()
    clock = pygame.time.Clock()
    system = InputPlatform()
    threading.Thread(target=ParameterControl.open_control_window, args=(system,), daemon=True).start()

    while True:
        dt = clock.tick(FPS) / 1000.0

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

        y_wheel, y_desk = system.update_motion(dt)
        Drawing.draw_scene(y_wheel, y_desk, system)
        pygame.display.flip()

if __name__ == "__main__":
    main()


